# Кампус Сириус
## by Ядерные Бобры
___
### Навигация по ТЗ:

- [ТЗ-0: API-контракты и единые правила написания кода](./tz-0-api-contracts-and-code-standards.md)
- [ТЗ-1: Модели баз данных микросервисов](./tz-1-database-models.md)


___


1\. Архитектурные принципы

Каждый сервис должен быть автономным и владеть своими данными.

- **Database per Service:** У каждого микросервиса своя БД. Прямые запросы в БД чужого сервиса **строго запрещены**.
- **API Gateway:** Все внешние запросы идут через единую точку входа. Внутренние сервисы не должны быть доступны извне напрямую.
- **Stateless:** Сервисы не хранят состояние сессии. Любой экземпляр сервиса должен быть заменяемым.

* * *

2\. Коммуникации между сервисами

Синхронное взаимодействие (gRPC)

Используется, когда нужен немедленный ответ или строгая типизация контрактов.

- **Инструментарий:** `grpclib` или `betterproto` для FastAPI.
- **Правило:** Не выстраивать цепочки более чем из 2-х синхронных вызовов (проблема "Distributed Stack Trace").

Асинхронное взаимодействие (RabbitMQ)

Используется для уведомлений, фоновых задач и обеспечения Eventual Consistency.

- **Протокол:** AMQP.
- **Библиотека:** `aio-pika`.
- **Формат сообщения:** JSON или CloudEvents.

* * *

3\. Паттерны обеспечения целостности и отказоустойчивости

Transactional Outbox

Для гарантии того, что событие в RabbitMQ будет отправлено только в случае успешного коммита в БД.

- **Реализация:** Записывать событие в таблицу `outbox` в той же транзакции, что и бизнес-данные. Отдельный релей (Relay) читает таблицу и шлет в RabbitMQ.

Saga (Orchestration-based)

Для распределенных транзакций (например, "Заказ -> Оплата -> Склад").

- Использовать **Оркестратор** (отдельный сервис или логика в стартовом сервисе), который последовательно вызывает другие сервисы и инициирует **компенсирующие транзакции** при сбое.

CQRS & Event Sourcing

- **CQRS:** Разделять модели на чтение (Read) и запись (Write), если сервис высоконагружен.
- **Event Sourcing:** Состояние агрегата восстанавливается из последовательности событий (применяется только в критически важных узлах, где нужен аудит каждого шага).

* * *

4\. Технические требования к коду (FastAPI)

Структура проекта

Соблюдать Clean Architecture:

Внутри каждого модуля внутри микросервиса должны быть описаны:

- `api`: Маршруты и эндпоинты.
- `app/models`: Модели БД (SQLAlchemy/Tortoise).
- `schemas`: Pydantic модели (DTO).
- `services`: Бизнес-логика.
- `repository`: Слой работы с данными.

Обработка ошибок

- Использовать кастомные исключения, которые перехватываются через `exception_handler`.
- Ответ при ошибке должен иметь формат: `{"error_code": "...", "message": "...", "details": {}}`.

Health Checks

Каждый сервис обязан иметь эндпоинты:

- `GET /health/liveness` — сервис запущен.
- `GET /health/readiness` — сервис готов принимать трафик (БД доступна, брокер доступен).

* * *

5\. Наблюдаемость (Observability)

- **Logging:** Только структурированный JSON-логи в `stdout`. Обязательно поле `trace_id` (передается через заголовки gRPC/HTTP и сообщения RabbitMQ).
- **Metrics:** Экспорт метрик в формате Prometheus (использовать `prometheus_fastapi_instrumentator`).
- **Tracing:** Интеграция с OpenTelemetry для визуализации пути запроса.

* * *

6\. База данных и Миграции

- **Миграции:** Использование `Alembic`. Миграции — часть CI/CD.
- **Пулинг:** Обязательное использование асинхронных драйверов (например, `asyncpg`).
- **Изоляция:** Запрещено использовать общие схемы БД.

* * *

Чек-лист перед мерджем (Definition of Done)

1.  Контракт gRPC описан в `.proto` файле и согласован.
2.  Описаны события (Events), которые сервис публикует в RabbitMQ.
3.  Настроены Health-чеки.
4.  Есть миграция БД (если нужно).
5.  Покрыто Unit-тестами (минимум 70% логики).
6.  Dockerfile оптимизирован (multi-stage build).

* * *
